package main

import (
	"encoding/json"
	"fmt"
	"os"
	"path/filepath"
	"reflect"
	"sort"
	"strings"
	"time"

	"github.com/spf13/cobra"
)

func main() {
	defer func() {
		if re := recover(); re != nil {
			fmt.Println(re)
		}
	}()
	if err := rootCmd.Execute(); err != nil {
		fmt.Println(err)
	}
}

var (
	rootCmd = &cobra.Command{
		Use:   "json2dart",
		Short: "json2dart is a converter",
		Long:  "json2dart is a converter generate dart class from json file",
		Run:   run,
	}
	jsonFilePath  string // json2dart.json
	dartClassName string // Json2Dart
	dartFileDir   string // ./
	dartFileName  string // json2dart.dart
)

const (
	dartMapKeyType   = "String"
	dartMapValueType = "dynamic"
)

func init() {
	rootCmd.PersistentFlags().StringVar(&jsonFilePath, "json-file-path", "json2dart.json", "The json file path")
	rootCmd.PersistentFlags().StringVar(&dartClassName, "dart-class-name", "Json2Dart", "The dart class name")
	rootCmd.PersistentFlags().StringVar(&dartFileDir, "dart-file-dir", "", "The dart file dir")
	rootCmd.PersistentFlags().StringVar(&dartFileName, "dart-file-name", "json2dart.dart", "The dart file name")
}

func run(*cobra.Command, []string) {
	buf, err := os.ReadFile(jsonFilePath)
	if err != nil {
		fmt.Println("读取json文件错误：" + err.Error())
		return
	}
	var m map[string]any
	err = json.Unmarshal(buf, &m)
	if err != nil {
		fmt.Println("解析json文件错误：" + err.Error())
		return
	}
	if len(m) <= 0 {
		return
	}
	opts := getOpts(m, &Option{ClassName: dartClassName, DartMapKeyType: dartMapKeyType, DartMapValueType: dartMapValueType, Fields: make([]*Field, 0)})
	if len(opts) <= 0 {
		return
	}
	tpl := executeTpl(opts)
	fileName := filepath.Join(dartFileDir, dartFileName)
	if err = os.WriteFile(fileName, []byte(getCopyright(buf)+tpl), 0700); err != nil {
		fmt.Println(err.Error())
	}
}

func setField(opt *Option, k string, v any, field *Field) (outOpts []*Option) {
	typeOf := reflect.TypeOf(v)
	kind := typeOf.Kind()
	switch kind {
	default:
		panic("未知的类型：" + kind.String())
	case reflect.Int, reflect.Int8, reflect.Int16, reflect.Int32, reflect.Int64, reflect.Uint, reflect.Uint8, reflect.Uint16, reflect.Uint32, reflect.Uint64:
		field.DataType = "int"
		field.Default = "0"
	case reflect.Float32, reflect.Float64:
		floatVal := reflect.ValueOf(v)
		setToInt := false
		if canFloat := floatVal.CanFloat(); canFloat {
			floatVV := floatVal.Float()
			if floatVV == float64(int(floatVV)) {
				setToInt = true
			}
		}
		if setToInt {
			field.DataType = "int"
			field.Default = "0"
		} else {
			field.DataType = "double"
			field.Default = "0.0"
		}
	case reflect.String:
		field.DataType = "String"
		field.Default = `""`
	case reflect.Map:
		classNameNext := opt.ClassName + case2UpperCamel(field.FieldName)
		field.FieldName = k
		field.DataType = classNameNext
		field.Default = "null"
		optNext := &Option{
			ClassName:        field.DataType,
			DartMapKeyType:   opt.DartMapKeyType,
			DartMapValueType: opt.DartMapValueType,
			Fields:           make([]*Field, 0),
		}
		outOpts = append(outOpts, getOpts(v.(map[string]any), optNext)...)
	case reflect.Slice, reflect.Array:
		field.Array = true
		if vv, ok := v.([]any); ok && len(vv) > 0 {
			outOpts = append(outOpts, setField(opt, k, vv[0], field)...)
		}
	}
	return
}

func getOpts(m map[string]any, opt *Option) (outOpts []*Option) {
	outOpts = append(outOpts, opt)
	var kk []string
	for k := range m {
		kk = append(kk, k)
	}
	sort.Strings(kk)
	for _, k := range kk {
		v := m[k]
		field := &Field{JsonName: k, FieldName: case2Camel(k)}
		opt.Fields = append(opt.Fields, field)
		outOpts = append(outOpts, setField(opt, k, v, field)...)
		if field.Array {
			field.DataType = fmt.Sprintf("List<%s>", field.DataType)
			field.Default = "[]"
		}
	}
	return
}

func case2Camel(str string) string {
	if str == "" {
		return str
	}
	str = strings.Replace(str, "_", " ", -1)
	str = strings.Title(str)
	str = strings.Replace(str, " ", "", -1)
	return strings.ToLower(str[:1]) + str[1:]
}

func case2UpperCamel(str string) string {
	if str == "" {
		return str
	}
	str = strings.Replace(str, "_", " ", -1)
	str = strings.Title(str)
	return strings.Replace(str, " ", "", -1)
}

func getCopyright(jsonBuf []byte) string {
	return `/*
Generated by json2dart (https://github.com/billcoding/json2dart)
Created at ` + time.Now().Format("2006-01-02T15:04:05") + `
-------------------------------------------------
` + string(jsonBuf) + `
*/

`
}
